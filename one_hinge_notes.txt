// Need to implement:
// Returns a tip free chain, possibly randomly chosen. For a hinged team,
// fixed nodes must not be returned unlress there are no other nodes.
// virtual FreeChain const& pick_tip_chain() const;
// Checks free_chains_.size() etc. are correct on entry to a mutation
// method. Called before calling mutation methods from evolve().
// virtual void mutation_invariance_check() const;


// calc_checksum():
//     // Only enforce (DEBUG) 0 < free_chains_.size() <= 2
//     // Compute & cascade checksum starting from each tip

// calc_score():
//     // Only enforce (DEBUG) 0 < free_chains_.size() <= 2
//     // NO NEED KABSCH - resample & calc RMS
//     // Simply loop through each tip and get min score

fix_limb_transforms():
    // Input arrow must not point towards fixed end

// grow_tip():
// nip_tip():
//     // No change

sever_limb():
    // Input arrow must not point towards fixed end

// copy_limb():
//     // No change

// erode_mutate():
//     // Receive tip node choice from virtual pick_tip_node()

delete_mutate():
    // Receive tip node choice from virtual pick_tip_node()
    // Must not include fixed end as deletable

insert_mutate():
    // Receive tip node choice from virtual pick_tip_node()
    // Must not include fixed end as insertable

swap_mutate():
    // Receive tip node choice from virtual pick_tip_node()
    // Must not include fixed end as swappable

cross_mutate():
    // Receive tip node choice from virtual pick_tip_node(), also call for father team
    // The portion near to fixed end must not be deleted as a result of cross

// regenerate():
//     // Receive tip node choice from virtual pick_tip_node()